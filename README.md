Проект: Go Base Auth API — тестовое задание для [MEDODS](https://medods.ru/)

> [!NOTE] Комментарий к решению (пожалуйста изучите перед просмотром решения)
> Так как детали выполнения задания оставали за мной (ответ по поводу доп. вопросов на `hh`), то хотел
> бы для начала расписать, как я понял задание.
>
> 1. Одно из требований к `access token`: Хранить токен в базе строго запрещено, что логично:)
> Но есть еще одно условие: на деавторизацию пользователя (поле выполнения этого запроса с access токеном, пользователю больше
> не должен быть доступен роут на получение его GUID и операция обновления токенов).
> Я понимаю так, что даже при валидном по времени `access token` операция должна быть прервана.
> Поэтому я решил добавить таблицу в базу данных `token_black_list` и добавлять туда токены по их `jti`.
> При утечке БД данные о `jti` токенов злоумышленнику ничего не дадут, а мы сможем блокировать `access_token`.
> **Важно**: я бы реализовал эту проверку с помощью `Redis`, но так как в списке технологий `Redis` не было, я создал
> таблицу под заблокированные токены (индекс на первичный ключ даст быстро блокировать их, но все равно операция тяжелая, так как
> при любом потенциальном запросе будет идти обращение к БД. В другой реализации сервиса я бы либо не блокировал `access_token`-ы
> (но может быть уменьшил их `TTL`), либо, как уже упомянул, кэшировал на время их `TTL`).
>
> 2. Необходимо запретить операцию обновления токенов при изменении `User-Agent`. При этом, после неудачной попытки выполнения операции, неоходимо > деавторизовать пользователя, который попытался выполнить обновление токенов.
> Тут у меня вопрос, кто такой «Пользователь»? «Пользователь» — это конечный пользователь или клиент? Так как я не понял, кем он является, реализовал два сценария:
> * При смене `User-Agent` деавторизируются все клиенты (то есть закрываются все сессии пользователя)
> * При явном выходе пользователя (`Logout`) деавтаризируется только его клиент, с которого запрашивается деавторизация (например, браузер, но на телефоне у условного пользователя доступ останется)
> Если уточните формулировку «Пользователя», раскачу один сценарий на всю логику системы.
>
> 3. IP адресса
> IP адресса вероятнее всего будет на продакшене передавать веб-сервер (может NGINX), поэтому я работал с заголовками `X-Forwarded-For`
>


## **Обзор проекта**

Go Base Auth API — это сервис аутентификации, разработанный на Go, который предоставляет набор конечных точек API для управления токенами доступа (access) и обновления (refresh).

## **Используемые инструменты**

Для реализации и развертывания сервиса используются следующие технологии:

*   **Go**: Основной язык программирования.
*   **PostgreSQL**: хранение информации о пользователях, хэшей `refresh` токенов и списка заблокированных токенов.
*   **Docker**
*   **`Fiber`**: HTTP-фреймворк.
*   **`golang-jwt/jwt/v5`**: Библиотека для работы с JWT токенами.
*.  **`goose`**: Библиотека для работа с миграциями.
*   **`google/uuid`**: Библиотека для генерации UUID.
*   **`joho/godotenv`**: Библиотека для загрузки переменных окружения из `.env` файла.
*   **`lib/pq`**: Драйвер PostgreSQL для Go.
*   **`golang.org/x/crypto/bcrypt`**: Используется для безопасного хэширования refresh токенов.
*   **`swaggo/swag`**: Инструмент для автоматической генерации Swagger документации.

## **Возможности**

Сервис предоставляет четыре основные конечные точки API для управления аутентификацией и авторизацией:

*   **Получение пары токенов (access и refresh)**: Позволяет клиентам получить новую пару токенов, используя уникальный идентификатор пользователя (GUID).
*   **Обновление пары токенов**: Обеспечивает возможность получения новой пары токенов с использованием существующего refresh токена.
*   **Получение GUID (UUID) текущего пользователя**: Возвращает идентификатор пользователя, связанного с предоставленным access токеном.
*   **Деавторизация пользователя**: Позволяет пользователю отозвать токен текущей сессии.

## **Требования к токенам**

### **Access Token (JWT)**

1.  **Формат**: JSON Web Token (JWT).
2.  **Алгоритм подписи**: SHA512 (HMAC SHA512).
3.  **Полезная нагрузка (Payload)**: Содержит следующие поля:
    *   `sub` (subject): Идентификатор пользователя (GUID).
    *   `jti` (JWT ID): Уникальный идентификатор JWT, связывающий access токен с соответствующим refresh токеном.
    *   `exp` (expiration time): Время истечения срока действия токена в формате Unix timestamp.
    *   `iat` (issued at): Время выдачи токена в формате Unix timestamp.

### **Refresh Token**

1.  **Формат**: Произвольный. Генерируется как случайная (криптографический генератор) последовательность байтов.
2.  **Передача**: Должен передаваться только в формате `base64`.
3.  **Хранение**: В базе данных хранится строго в виде `bcrypt` хэша.
4.  **Защита от повторного использования**: После успешного использования refresh токена для обновления, старый refresh токен отзывается (удаляется из базы данных).
5.  **Защита от изменений на стороне клиента**: Поскольку в базе данных хранится хэш refresh токена, любая попытка клиента изменить токен сделает его невалидным при проверке.

### **Требования к операции Refresh**

1.  **Связанность токенов**: Операцию `refresh` можно выполнить только той парой токенов, которая была выдана вместе. Это гарантируется путем связывания access и refresh токенов через общий `jti` (JWT ID).
2.  **Проверка `User-Agent`**: При попытке обновления токенов, `User-Agent` клиента сравнивается с `User-Agent`, который был записан при выдаче оригинального refresh токена.
    *   Если `User-Agent` не совпадает, операция обновления **отклоняется**, и **все** токены обновления для этого пользователя немедленно отзываются, что фактически деавторизует пользователя во всех его сессиях (до истечения последних выданных **access token**-ов).
3.  **Уведомление о новом IP**: Если `IP-адрес` клиента при попытке обновления токенов отличается от IP-адреса, с которого был выдан оригинальный refresh токен:
    *   Операция обновления токенов **не запрещается**.
    *   Сервис отправляет POST-запрос на заданный `webhook` (`NOTIFICATION_WEBHOOK_URL`). Так как в ТЗ не представлена форма `JSON` для отправки данных, сервер отправляет форму в виде:

    ```json
      "user_id": "db3fdad9-4368-44fb-93ff-8bc2b52737e3", // user_id в формате GUID
      "old_ip_address": "192.168.0.1", // старый ip пользователя
      "new_ip_address": "192.168.0.1", // новый ip пользователя
      "timestamp": "2025-07-24T09:59:43+04:00" // время операции в формате timestapm+tz
    ```


## **Предварительные требования**

* TODO: написать предварительные требования

## **Инструкции по запуску**

1.  Убедитесь, что у вас есть файл `.env` в корневой директории. Для примера создания `.env` файла нужно взять `.env_example` из исходного кода проекта:
2.  Запустите все сервисы одной командой из корневой директории проекта:
    ```bash
    docker-compose -f docker-compose.yml up -d
    ```
    Эта команда:
    *  TODO: написать что произойдет

## **Swagger Документация**

После успешного запуска сервиса, интерактивная Swagger UI документация будет автоматически сгенерирована и доступна по адресу:
`http://localhost:8000/swagger/index.html`
**ВАЖНО**: если вы сменили `APPLICATION_PORT` в приложении, смените его и в этом адресе:)

## **Конечные точки API и примеры использования**

### **1. Генерация новой пары токенов**

*   **Endpoint**: `POST /api/v1/auth/token`
*   **Описание**: Генерирует новую пару access и refresh токенов для указанного идентификатора пользователя. Если пользователь с таким `user_id` ещё не существует в базе данных, он будет добавлен.
*   **Параметры запроса (Query)**:
    *   `user_id` (string, required, format: uuid): Уникальный идентификатор пользователя (GUID), для которого генерируются токены.
*   **Пример успешного ответа (200 OK)**:
    ```json
    {
      "access_token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9...",
      "refresh_token": "V29uZGVyZnVsIHJlZnJlc2ggdG9rZW4h"
    }
    ```
*   **Возможные ошибки**:
    *   `400 Bad Request`: `{"error": "user_id is required"}` (если параметр `user_id` отсутствует).
    *   `422 Unprocessable Entity`: `{"error": "user_id must be a valid UUID"}` (если `user_id` не соответствует формату UUID).
    *   `500 Internal Server Error`: `{"error": "could not generate tokens"}` (общая ошибка сервера при генерации токенов).

### **2. Обновление пары токенов**

*   **Endpoint**: `POST /api/v1/auth/token/refresh`
*   **Описание**: Обновляет существующую пару токенов, используя валидный refresh токен. Эта операция является защищенной и требует наличия валидного access токена в заголовке `Authorization`.
*   **Защита**: `ApiKeyAuth` (требуется `Authorization` заголовок с префиксом `Bearer`).
*   **Параметры запроса (Header)**:
    *   `Authorization` (string, required): `Bearer {access_token}`.
*   **Параметры запроса (Body)**:
    *   `refresh_token` (string, required): Raw `base64` закодированный refresh токен.
*   **Пример успешного ответа (200 OK)**:
    ```json
    {
      "access_token": "eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9...",
      "refresh_token": "V29uZGVyZnVsIHJlZnJlc2ggdG9rZW4h"
    }
    ```
*   **Возможные ошибки**:
    *   `422 Unprocessable Entity`: `{"error": "refresh token is invalid format"}` (если тело запроса некорректно или refresh токен не в формате `base64`).
    *   `401 Unauthorized`:
        *   `{"error": "invalid token"}` (если access токен невалиден или отсутствует, или refresh токен не может быть проверен).
        *   `{"error": "token has been revoked"}` (если refresh токен был отозван).
        *   `{"error": "refresh token is invalid"}` (если refresh токен не найден в базе данных).
        *   `{"error": "access token is not pair to refresh token"}` (если `jti` access токена не совпадает с `jti` refresh токена).
        *   `{"error": "token is blocker"}` (если `access token` заблокирован).
        *   `{"error": "user agent changed, please autentificate again"}` (если `User-Agent` клиента не совпадает с тем, что был сохранен при выдаче refresh токена; при этом все токены пользователя отзываются).
    *   `500 Internal Server Error`: `{"error": "cant refresh tokens"}` (общая ошибка сервера при попытке обновления токенов).

### **3. Получение GUID текущего пользователя**

*   **Endpoint**: `GET /api/v1/user/me`
*   **Описание**: Возвращает GUID пользователя, связанного с предоставленным access токеном. Этот роут защищен и требует валидный access токен.
*   **Защита**: `ApiKeyAuth` (требуется `Authorization` заголовок с префиксом `Bearer`).
*   **Параметры запроса (Header)**:
    *   `Authorization` (string, required): `Bearer {access_token}`.
*   **Пример успешного ответа (200 OK)**:
    ```json
    {
      "user_id": "a1b2c3d4-e5f6-7890-1234-567890abcdef"
    }
    ```
*   **Возможные ошибки**:
    *   `401 Unauthorized`:
      * `{"error": "invalid token"}` (если access токен невалиден или отсутствует).
      * `{"error": "token is blocker"}` (если `access token` заблокирован).

### **4. Деавторизация пользователя**

*   **Endpoint**: `POST /api/v1/auth/token/logout`
*   **Описание**: Отзывает все refresh токены для текущего пользователя, эффективно завершая все его сессии. После выполнения этого запроса, пользователю больше не будут доступны защищенные роуты (такие как `/api/v1/user/me` и `/api/v1/auth/token/refresh`) с использованием старых токенов.
*   **Защита**: `ApiKeyAuth` (требуется `Authorization` заголовок с префиксом `Bearer`).
*   **Параметры запроса (Header)**:
    *   `Authorization` (string, required): `Bearer {access_token}`.
*   **Пример успешного ответа (200 OK)**:
    ```json
    {
      "message": "logged out successfully"
    }
    ```
*   **Возможные ошибки**:
    *   `401 Unauthorized`:
        * `{"error": "invalid token"}` (если access токен невалиден или отсутствует).
        *   `{"error": "token is blocker"}` (если `access token` заблокирован).
    *   `500 Internal Server Error`: `{"error": "could not logout"}` (общая ошибка сервера при отзыве токенов).

## **Единый пример использования API (cURL)**

Полный жизненный цикл токенов с использованием `curl` представлен по пути `tests/requests_entrypoint.sh`

Для запуска:
1. Выдайте исполнительные права программе:
```bash
chmod +x tests/rerequests_entrypoint.sh
```

2. И запустите:)
```bash
./tests/rerequests_entrypoint.sh
```

**Псс**: это не `e2e` тест, я написал просто реализацую запросов в `shell`, поэтому запустите перед этим сервис:)
